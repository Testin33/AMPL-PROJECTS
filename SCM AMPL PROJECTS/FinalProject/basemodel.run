# ==============================
# basemodel.run
# ==============================


model basemodel.mod;
data  basemodel.dat;


option solver cplex;

solve;

# Mostrar valor óptimo de la función objetivo
display Total_Distance;

# Que AMPL no imprima filas/columnas con todo cero
option omit_zero_rows 1;

printf "\n=== Active arcs (x[k,i,j] = 1) ===\n";
display {k in K, i in V, j in V: i != j and x[k,i,j] > 0.5} x[k,i,j];

printf "\n=== Vehicle loads (load[k,i] > 0) ===\n";
display {k in K, i in V: load[k,i] > 0.0001} load[k,i];

printf "\n=== Service start times (s[k,i] > 0) ===\n";
display {k in K, i in V: s[k,i] > 0.0001} s[k,i];

# =======================================
# Imprimir rutas ordenadas para cada k ∈ K
# =======================================

printf "\n=== Rutas por vehículo ===\n";

param current;
param nxt;
for {k in K} {

    # ¿Este vehículo se usa?
    if sum{i in V, j in V} x[k,i,j] < 0.5 then {
        printf "Vehículo %s: no utilizado.\n", k;
    } else {
        printf "Vehículo %s: ", k;
        # Comenzamos en el depot 0
        let current := 0;
        printf "%d", current;

        repeat {
            # Buscar el siguiente nodo j tal que x[k,cur,j] = 1
            # Como el modelo obliga a un solo arco saliendo, 
            # el max sobre j en {h in V: x[k,cur,h] > 0.5} devuelve ese único nodo.
            let nxt := max{h in V: x[k,current,h] > 0.5} h;

            printf " -> %d", nxt;
            let current := nxt;
        } until current = 0;

        printf "\n";
    }
}


